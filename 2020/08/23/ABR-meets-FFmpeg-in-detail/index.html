<!-- build time:Sun Aug 23 2020 20:11:01 GMT+0800 (China Standard Time) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 4.2.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png"><link rel="mask-icon" href="/images/logo.svg" color="#222"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|EB Garamond:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"spartazhc.github.io",root:"/",scheme:"Gemini",version:"7.8.0",exturl:!1,sidebar:{position:"left",display:"post",padding:18,offset:12,onmobile:!1},copycode:{enable:!0,show_result:!1,style:null},back2top:{enable:!0,sidebar:!1,scrollpercent:!0},bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},path:"search.xml"}</script><meta name="description" content="I participated in GSoC 2020, my project is “ABR meets FFmpeg” which aim to add an ABR module to FFmpeg. Here I will talk about my project in detail."><meta property="og:type" content="article"><meta property="og:title" content="ABR meets FFmpeg, in detail"><meta property="og:url" content="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/index.html"><meta property="og:site_name" content="spartazhc&#39;s blog"><meta property="og:description" content="I participated in GSoC 2020, my project is “ABR meets FFmpeg” which aim to add an ABR module to FFmpeg. Here I will talk about my project in detail."><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/hls-origin.png"><meta property="og:image" content="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/ffplay-switch.png"><meta property="og:image" content="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/hls-abr.png"><meta property="og:image" content="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/abr-switch.png"><meta property="article:published_time" content="2020-08-23T11:52:45.000Z"><meta property="article:modified_time" content="2020-08-23T11:52:45.000Z"><meta property="article:author" content="spartazhc"><meta property="article:tag" content="FFmpeg"><meta property="article:tag" content="GSoC"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/hls-origin.png"><link rel="canonical" href="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>ABR meets FFmpeg, in detail | spartazhc's blog</title><script>function sendPageView(){if(CONFIG.hostname===location.hostname){var e=localStorage.getItem("uid")||Math.random()+"."+Math.random();localStorage.setItem("uid",e),navigator.sendBeacon("https://www.google-analytics.com/collect",new URLSearchParams({v:1,tid:"UA-168851576-1",cid:e,t:"pageview",dp:encodeURIComponent(location.pathname)}))}}document.addEventListener("pjax:complete",sendPageView),sendPageView()</script><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript><link rel="alternate" href="/atom.xml" title="spartazhc's blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span><h1 class="site-title">spartazhc's blog</h1><span class="logo-line-after"><i></i></span></a></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a href="https://github.com/spartazhc" class="github-corner" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><main class="main"><div class="main-inner"><div class="content-wrap"><div class="content post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.png"><meta itemprop="name" content="spartazhc"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="spartazhc's blog"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">ABR meets FFmpeg, in detail</h1><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2020-08-23 19:52:45" itemprop="dateCreated datePublished" datetime="2020-08-23T19:52:45+08:00">2020-08-23</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/FFmpeg/" itemprop="url" rel="index"><span itemprop="name">FFmpeg</span></a> </span></span><span id="/2020/08/23/ABR-meets-FFmpeg-in-detail/" class="post-meta-item leancloud_visitors" data-flag-title="ABR meets FFmpeg, in detail" title="阅读次数"><span class="post-meta-item-icon"><i class="fa fa-eye"></i> </span><span class="post-meta-item-text">阅读次数：</span> <span class="leancloud-visitors-count"></span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Valine：</span> <a title="valine" href="/2020/08/23/ABR-meets-FFmpeg-in-detail/#valine-comments" itemprop="discussionUrl"><span class="post-comments-count valine-comment-count" data-xid="/2020/08/23/ABR-meets-FFmpeg-in-detail/" itemprop="commentCount"></span></a></span><br><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>24k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>22 分钟</span></span></div></header><div class="post-body" itemprop="articleBody"><div class="note default"><p>I participated in GSoC 2020, my project is “ABR meets FFmpeg” which aim to add an ABR module to FFmpeg. Here I will talk about my project in detail.</p></div><a id="more"></a><h2 id="what-are-we-talking-about-when-we-talk-ABR-in-FFmpeg"><a href="#what-are-we-talking-about-when-we-talk-ABR-in-FFmpeg" class="headerlink" title="what are we talking about when we talk ABR in FFmpeg?"></a>what are we talking about when we talk ABR in FFmpeg?</h2><h3 id="What-is-ABR"><a href="#What-is-ABR" class="headerlink" title="What is ABR?"></a>What is ABR?</h3><blockquote><p><strong>Adaptive bitrate streaming</strong> is a technique used in streaming multimedia over computer networks.</p><p>It works by detecting a user’s bandwidth and CPU capacity in real time and adjusting the quality of the media stream accordingly.</p><p>The player client switches between streaming the different encodings depending on available resources.</p><p>–from wikipedia</p></blockquote><p>ABR algorithms are classified into three broad categories: throughput-based, buffer-based, and hybrid schemes.</p><ol><li><p><strong>Throughput-based</strong> algorithms work by estimating the network throughput available between the client and server and using that estimate to decide on bitrate of next segment that is to be down-loaded.</p></li><li><p><strong>Buffer-based</strong> algorithms predominantly use the level to which the buffer is full to decide on the bitrate of the next segment.</p></li><li><p><strong>Hybrid</strong> algorithms use both throughput prediction and buffer levels in an attempt to exploit the advantages of both.</p></li></ol><h3 id="Why-we-need-abr-in-FFmpeg"><a href="#Why-we-need-abr-in-FFmpeg" class="headerlink" title="Why we need abr in FFmpeg?"></a>Why we need abr in FFmpeg?</h3><p><strong>Adaptive bitrate(ABR), aiming to pick next chunks’ bitrate to overcome the fluctuation of network conditions</strong>, is a non-trivial method to ensure good quality-of-experience (QoE) for Internet video (such as DASH and HLS). Exploring the aforementioned FFmpeg projects, however, lacks the essential ABR module. To that end, support ABR methods in FFmpeg.</p><h3 id="What-is-different-when-add-ABR-to-FFmpeg"><a href="#What-is-different-when-add-ABR-to-FFmpeg" class="headerlink" title="What is different when add ABR to FFmpeg?"></a>What is different when add ABR to FFmpeg?</h3><p>Adding ABR to FFmpeg have to adapt all things to FFmpeg, which is not a “real” player. Things are really limited in FFmpeg, abr in FFmpeg can not working like <em>dash.js</em> (dash reference player).</p><p>In dash.js, mechanism and information are already there. ABRControler should only deal with abr algorithms, others will be done with StreamController. Therefore, many researcher implement there own ABR algorithms and test them on dash.js.</p><p>In FFmpeg, there are no switch mechanism for HLS / DASH. So what really matters when implement ABR feature in FFmpeg is to <strong>build a switch mechanism</strong>.</p><p>As for ABR algorithms in detail, as I have said, things are limited in FFmpeg. Fancy ABR algorithms are not what we need in the begining, I choose the simplest throughput based algorithm. Maybe we could add more ABR algorithms to ffabr protocol in FFmpeg. (If we really need it.)</p><h3 id="limitations-in-FFmpeg-to-implement-ABR"><a href="#limitations-in-FFmpeg-to-implement-ABR" class="headerlink" title="limitations in FFmpeg to implement ABR"></a>limitations in FFmpeg to implement ABR</h3><p>There are several limitations in FFmpeg when implementing ABR:</p><ul><li><p>No buffer</p></li><li><p>Segment download does not in a seperate thread.</p><ul><li>throughput estimate may not accurate.</li></ul><h3 id="What-is-done-briefly"><a href="#What-is-done-briefly" class="headerlink" title="What is done briefly"></a>What is done briefly</h3></li><li><p><strong>ffabr.c</strong>: an internal protocol.</p><ul><li>A throughput based algorithm.</li><li>Return whether to switch, if so, to which variant.</li></ul></li><li><p><strong>hls.c</strong>: a switch mechanism.</p><ul><li>Use ffabr protocol.</li><li>Switch between different variant.</li><li>Return pkt transparently to ffplay.</li></ul></li><li><p><strong>ffplay.c</strong>:</p><ul><li>When use abr, process pkts to playback correctly.</li></ul></li></ul><h2 id="Structure"><a href="#Structure" class="headerlink" title="Structure"></a>Structure</h2><h3 id="original-hls"><a href="#original-hls" class="headerlink" title="original hls"></a>original hls</h3><p><img src="hls-origin.png" alt="hls-origin"></p><h4 id="segment-download"><a href="#segment-download" class="headerlink" title="segment download"></a>segment download</h4><p>hls use <code>avio</code> to manage segment data. In <code>hls_read_data</code>, after <code>parse_playlist</code>, hls will init avio for all playlists using:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// INITIAL_BUFFER_SIZE is 32768</span></span><br><span class="line">ffio_init_context(&amp;pls-&gt;pb, pls-&gt;read_buffer, INITIAL_BUFFER_SIZE, <span class="number">0</span>, pls,</span><br><span class="line">                          read_data, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><p>Function <code>read_data</code> is bind to avio’s <code>read_packet</code>, <code>read_data</code> basically do:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read_data main structure - simplist</span></span><br><span class="line"><span class="comment">** input: void *opaque</span></span><br><span class="line"><span class="comment">** return: uint8_t *buf</span></span><br><span class="line"><span class="comment">**         int buf_size</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* if the avio of playlist is closed, download a segment */</span></span><br><span class="line"><span class="keyword">if</span> (!v-&gt;input) &#123;</span><br><span class="line">    ...</span><br><span class="line">    seg = current_segment(v);</span><br><span class="line">    ret = open_input(c, v, seg, &amp;v-&gt;input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* fill buffer: read_from_url will call avio_read to read from pls-&gt;input*/</span></span><br><span class="line">seg = current_segment(v);</span><br><span class="line">ret = read_from_url(v, seg, buf, buf_size);</span><br><span class="line"><span class="comment">/* ret &gt; 0 means there are data in pls-&gt;input to read */</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ff_format_io_close(v-&gt;parent, &amp;v-&gt;input);</span><br></pre></td></tr></table></figure><p>In short, there is no buffer in segment level, hls will not buffer more segment of one playlist. hls only download a segment when the avio of the last segment is used up.</p><h4 id="stream-cycle-switch"><a href="#stream-cycle-switch" class="headerlink" title="stream cycle (switch)"></a>stream cycle (switch)</h4><p>hls.c does not switch playlists spontaneously, ffplay.c call it.</p><p><img src="ffplay-switch.png" alt="ffplay-switch"></p><h5 id="ffplay-initiate-the-switch"><a href="#ffplay-initiate-the-switch" class="headerlink" title="ffplay initiate the switch"></a>ffplay initiate the switch</h5><p>ffplay’s SDL event_loop will receive keyboard event ‘a’, ‘v’, ‘c’ to cycle stream channel. What is done in <code>stream_cycle_channel(VideoState *is, int codec_type)</code> is to get the <code>stream_index</code> of the given <code>codec_type</code>, then close the old stream and open the new one:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">stream_component_close(is, old_index);</span><br><span class="line">stream_component_open(is, stream_index);</span><br></pre></td></tr></table></figure><p>In <code>stream_component_close()</code>, it will abort and destroy the decoder, set <code>stream-&gt;discard</code> to <code>AVDISCARD_ALL</code>. In <code>stream_component_open()</code>, the decoder will be initied and <code>stream-&gt;discard</code> will be set to <code>AVDISCARD_DEFAULT</code>.</p><h5 id="hls-do-the-switch"><a href="#hls-do-the-switch" class="headerlink" title="hls do the switch"></a>hls do the switch</h5><p>Then, in hls.c, at the begining of <code>hls_read_packet</code>, function <code>recheck_discard_flags</code> will be called to check <code>stream-&gt;discard</code> flag, to see whether the playlist is needed. If there is a change, then the playlist switch happens.</p><p>There will be further influence after the discard flag is changed.</p><p>In <code>recheck_discard_flags()</code>, there is a for loop of all playlists, if one playlist changes to needed, then some parameters will be set to make sure this playlist can catch up to cur_timestamp.</p><p>In <code>read_data()</code>, it will return <code>AVERROR_EOF</code> if the playlist is not needed.</p><p>In <code>hls_read_packet()</code>, it will not call <code>av_read_frame</code> for playlists which are not needed.</p><h5 id="user-experience"><a href="#user-experience" class="headerlink" title="user experience"></a>user experience</h5><p>It does not feel very good when you cycle streams in ffplay. The new stream will playback from the next segment to catch up, which is kind of annoying.</p><h4 id="http-multiple"><a href="#http-multiple" class="headerlink" title="http_multiple"></a>http_multiple</h4><p>hls.c has a <code>http_multiple</code> option. When the <code>http_multiple</code> is enabled, each playlist will mantain another <code>AVIOContext *input_next</code> as well. In function <code>read_data()</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* read_data main structure - http_multiple</span></span><br><span class="line"><span class="comment">** input: void *opaque</span></span><br><span class="line"><span class="comment">** return: uint8_t *buf</span></span><br><span class="line"><span class="comment">**         int buf_size</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* if the avio of playlist is closed, download a segment */</span></span><br><span class="line"><span class="keyword">if</span> (!v-&gt;input) &#123;</span><br><span class="line">    ...</span><br><span class="line">    seg = current_segment(v);</span><br><span class="line">    <span class="comment">/* if there is v-&gt;input_next requested, no need to download, just swap */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;http_multiple == <span class="number">1</span> &amp;&amp; v-&gt;input_next_requested) &#123;</span><br><span class="line">        FFSWAP(AVIOContext *, v-&gt;input, v-&gt;input_next);</span><br><span class="line">        v-&gt;input_next_requested = <span class="number">0</span>;</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ret = open_input(c, v, seg, &amp;v-&gt;input);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">seg = next_segment(v);</span><br><span class="line"><span class="keyword">if</span> (c-&gt;http_multiple == <span class="number">1</span> &amp;&amp; !v-&gt;input_next_requested) &#123;</span><br><span class="line">    ret = open_input(c, v, seg, &amp;v-&gt;input_next);</span><br><span class="line">    v-&gt;input_next_requested = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* fill buffer: read_from_url will call avio_read to read from pls-&gt;input*/</span></span><br><span class="line">seg = current_segment(v);</span><br><span class="line">ret = read_from_url(v, seg, buf, buf_size);</span><br><span class="line"><span class="comment">/* ret &gt; 0 means there are data in pls-&gt;input to read */</span></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">ff_format_io_close(v-&gt;parent, &amp;v-&gt;input);</span><br></pre></td></tr></table></figure><p>It seems that <code>http_multiple</code> just download the next segment every time. It looks similar to a “buffer” but not. I do not really see the benefit of <code>http_multiple</code>.</p><h4 id="http-persistent"><a href="#http-persistent" class="headerlink" title="http_persistent"></a>http_persistent</h4><p><code>http_persistent</code> is really a good feature. It can reuse a http connection to download segments, which saves the resource and time to create a http request every time. When the <code>http_persistent</code> option is enabled, hls will call <code>open_url_keeplive()</code> instead of <code>open_url()</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">open_url_keepalive</span><span class="params">(AVFormatContext *s, AVIOContext **pb,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> <span class="keyword">char</span> *url, AVDictionary **options)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    URLContext *uc = ffio_geturlcontext(*pb);</span><br><span class="line">    av_assert0(uc);</span><br><span class="line">    (*pb)-&gt;eof_reached = <span class="number">0</span>;</span><br><span class="line">    ret = ff_http_do_new_request2(uc, url, options);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ff_format_io_close(s, pb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Sadly, the proposed abr protocol may not support it. Just like crypto protocol, as a wrapper to call http protocol, it creates a http request for each segment. (Maybe we could see whether we can pass it further on.)</p><h3 id="hls-ffabr"><a href="#hls-ffabr" class="headerlink" title="hls + ffabr"></a>hls + ffabr</h3><ul><li>Added ffabr protocol to download segment and return switch request, ffabr will be introduced later.</li></ul><p><img src="hls-abr.png" alt="hls-abr"></p><ul><li>When enable abr, there is a switch mechanism to switch variants, the most important thing is to change the <code>stream.discard</code> flag properly.</li></ul><p><img src="abr-switch.png" alt="abr-switch"></p><h2 id="ffabr-protocol"><a href="#ffabr-protocol" class="headerlink" title="ffabr protocol"></a>ffabr protocol</h2><p>ABR need information to make decision, in different ABR algorithms, it could be throughput , buffer state, etc. But as shown by <code>read_data</code> function in last section, there is no real “buffer” in current hls.c implement. hls.c will not download next segment until current segment has no data to read. As a result, we can never use a buffer based ABR algorithm unless we add a buffer to hls, which may be too complete and no reason to do.</p><p>So, in the first version of ffabr protocol, a throughput based algorithm is added. And it should be easy to add new algorithms to ffabr.</p><h3 id="Protocol-Design"><a href="#Protocol-Design" class="headerlink" title="Protocol Design"></a>Protocol Design</h3><p>When I want to design the abr protocol, firstly, I need to figure out the following mechanisms:</p><ol><li>How does hls call this abr protocol?</li><li>How to get the results back to hls?</li></ol><p>By studying crypto protocol and cache protocol, and reading the api of <code>URLProtocol</code>, I designed abr protocol:</p><p>abr protocol should be placed between demuxer hls/dash and http/https (simillar to crypto). It should get information from hls.c, call http/https as its sub protocol to download segments, collect the elapsed time, and return</p><p>URLProtocol has apis like:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> URLProtocol ff_ffabr_protocol = &#123;</span><br><span class="line">    .name            = <span class="string">"ffabr"</span>,</span><br><span class="line">    .url_open2       = abr_open,</span><br><span class="line">    .url_read        = abr_read,</span><br><span class="line">    .url_seek        = abr_seek,</span><br><span class="line">    .url_close       = abr_close,</span><br><span class="line">    .priv_data_size  = <span class="keyword">sizeof</span>(ABRContext),</span><br><span class="line">    .priv_data_class = &amp;ffabr_class,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>abr protocol will use AVOption metadata to communicate with hls.c.</p><ul><li><p><code>abr-params</code> is in type of <code>AV_OPT_TYPE_DICT</code>, it works as input from hls to ffabr protocol. It contains following information:</p><ul><li>format: hls / dash</li><li>cur_var: current variant</li><li>type: type of segment to be download</li><li>can_switch: whether a switch request can be make</li><li>n_variants: number of variants</li><li>variant_bitrate#: bitrate of each variant</li><li>n_throughputs: number of throughput data</li><li>throughputs: throughputs in kbps</li></ul></li><li><p><code>abr-metadata</code> is also <code>AV_OPT_TYPE_DICT</code>, it works as output of ffabr protocol.</p></li></ul><h3 id="basic-structure"><a href="#basic-structure" class="headerlink" title="basic structure"></a>basic structure</h3><p>In function <code>abr_open</code>, firstly, the url is checked to make sure it has a prefix of “ffabr”. After the input parameter dictionary <code>abr_params</code> is parsed, <code>ffurl_open_whitelist</code>is called to open sub protocols to download the segment, and the download time will be recorded(to calculate the throughput). Then, if the value of <code>can_switch</code> is true, an abr rule will be called (a simple throughput based algorithm for now, but we could add more) to see whether a variant switch is need in current network status.</p><p>The function <code>abr_read()</code> will call <code>ffurl_read()</code> to read from its sub protocol.</p><p>The function <code>abr_seek()</code> supports seek.</p><p>The function <code>abr_close()</code> will close sub protocol and do free works.</p><h3 id="throughput-based-algorithm"><a href="#throughput-based-algorithm" class="headerlink" title="throughput based algorithm"></a>throughput based algorithm</h3><p>An simple throughput based algorithm is implemented, whose main idea is to estimate throughput, and choose the variant with highest bitrate we could afford.</p><p>To avoid bitrate oscillation, the algorithm will not make switches if bw_estimate is close to current variant’s bitrate. Then we will choose the variant with highest bitrate smaller than bw_estimate. If the ret is same to current variant, then no switch is needed.</p><p>There is some restrain of the throughput based algorithm. The bw_estimate is the harmonic mean of the most recent <code>ABR_THROUGHPUT_FIFO_LEN</code> samples. Since the segment is download by http/https protocol, and ffabr can only record the time of <code>ffurl_open_whitelist</code>, the download time could be larger than the real value.</p><h2 id="switch-mechanism"><a href="#switch-mechanism" class="headerlink" title="switch mechanism"></a>switch mechanism</h2><p>To achieve best user experience, we cannot take ffplay’s stream cycle way to switch between variants. Instead, the implemented switch mechanism will be transparent to ffplay.</p><p>There are two main purpose of the switch mechanism:</p><ul><li>The switch should be make at the exact time of the end of a segment.</li><li>The downloaded segment should not be wasted.</li></ul><p>Some features of HLS should be concerned:</p><ul><li><p>Variant</p><blockquote><ul><li>Each Variant Stream MUST present the same content.</li><li>Matching content in Variant Streams MUST have matching timestamps. This allows clients to synchronize the media.</li><li>Matching content in Variant Streams MUST have matching timestamps. This allows clients to synchronize the media.</li></ul></blockquote></li><li><p>Rendition Groups</p><blockquote><p>A set of one or more EXT-X-MEDIA tags with the same GROUP-ID value and the same TYPE value defines a Group of Renditions. Each member of the Group MUST be an alternative Rendition of the same content.</p></blockquote></li></ul><p>The restrain of variants make sure we could switch between the playlists which contains same type of content without any timestamp problem. The rendition group means there could be variant constructed by several renditions. The audio and video could be separated to different files, which means they may have different duration for their segments. The switch time of audio and video could be different.</p><p>Take all these to consideration, the switch mechanism is implemented as following:</p><ul><li>Parse the return <code>abr-metadata</code> from ffabr protocol, check whether a switch request is made</li><li>Add switch_task for each playlist in target variant, the switch_timestamp would be calculated properly</li><li>In function <code>recheck_discard_flags()</code>, if the switch_timestamp of remained switch_task reached the <code>c-&gt;current_timestamp</code>, then the discard flag of the streams in the playlists of the target variant will be set to <code>AV_DISCARD_DEFAULT</code>, and all the streams in other playlist which have same type with the targeted one should be set to <code>AV_DISCARD_ALL</code>.</li><li>Then <code>avio_flush(&amp;pls-&gt;pb)</code> and <code>avformat_flush(pls-&gt;ctx)</code> is called to avoid decode error.</li><li>In <code>hls_read_packet()</code>, above variant switch should take effect just at the first timestamp of the new segment. So the function <code>av_read_frame()</code> returns pkt of switched variant now.</li><li>ffplay get the packet, add to corrosponding queue, and play.</li></ul><h3 id="calculate-switch-timestamp"><a href="#calculate-switch-timestamp" class="headerlink" title="calculate switch_timestamp"></a>calculate switch_timestamp</h3><p>To calculate switch_timestamp, the following information is needed:</p><ul><li>The index of segment switch to.</li><li><code>first_timestamp</code> of stream, will be used to calculate segment timestamp.</li><li><code>delta_timestamp</code> of stream( the duration of one packet), will be use to calculate the last timestamp of a segment.</li></ul><p><code>first_timestamp</code> and <code>delta_timestamp</code> are initiated at the begining.</p><h3 id="skip-mechanism-in-read-data"><a href="#skip-mechanism-in-read-data" class="headerlink" title="skip mechanism in read_data"></a>skip mechanism in <code>read_data</code></h3><p>we will need two skip mechanism in<code>read_data()</code> to prevent waste of downloaded segment.</p><p>The first one is at the beginning of <code>read_data()</code>, when hls get the switch_request from ffabr, the current playlist is needed, but we do not need the next segment of this playlist. <code>read_data()</code> should return <code>AVERROR_EOF</code>.</p><p>The second one happens when we enable <code>http_multiple</code> option. If the <code>input_next</code> has been requested, we need to pass the first one skip, allow it to swap <code>input_next</code> to <code>input</code>, but skip download next segment to <code>input_next</code> since the switch request has been made.</p><h3 id="a-switch-example"><a href="#a-switch-example" class="headerlink" title="a switch example"></a>a switch example</h3><p>Here shows a switch example:</p><ul><li>the hls manifest “master.m3u8”</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#EXTM3U</span></span><br><span class="line"><span class="comment">#EXT-X-VERSION:3</span></span><br><span class="line"><span class="comment">#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="group_aud_low",NAME="audio_0",DEFAULT=YES,URI="out_0.m3u8"</span></span><br><span class="line"><span class="comment">#EXT-X-MEDIA:TYPE=AUDIO,GROUP-ID="group_aud_high",NAME="audio_1",DEFAULT=YES,URI="out_1.m3u8"</span></span><br><span class="line"><span class="comment">#EXT-X-STREAM-INF:BANDWIDTH=35200,CODECS="mp4a.40.2",AUDIO="group_aud_low"</span></span><br><span class="line">out_0.m3u8</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXT-X-STREAM-INF:BANDWIDTH=70400,CODECS="mp4a.40.2",AUDIO="group_aud_high"</span></span><br><span class="line">out_1.m3u8</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXT-X-STREAM-INF:BANDWIDTH=1135200,RESOLUTION=1280x720,CODECS="avc1.64001f,mp4a.40.2",AUDIO="group_aud_low"</span></span><br><span class="line">out_2.m3u8</span><br><span class="line"></span><br><span class="line"><span class="comment">#EXT-X-STREAM-INF:BANDWIDTH=3370400,RESOLUTION=1280x720,CODECS="avc1.64001f,mp4a.40.2",AUDIO="group_aud_high"</span></span><br><span class="line">out_3.m3u8</span><br></pre></td></tr></table></figure><ul><li>ffplay command using abr, here are the log</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">$ ./ffplay  -i http://localhost/live/master.m3u8  -abr -v info</span><br><span class="line">ffplay version N-98484-g7455aa2aab Copyright (c) 2003-2020 the FFmpeg developers</span><br><span class="line">  built with gcc 10.1.0 (GCC)</span><br><span class="line">  configuration: --<span class="built_in">disable</span>-doc --<span class="built_in">disable</span>-htmlpages --<span class="built_in">disable</span>-manpages --<span class="built_in">disable</span>-podpages --<span class="built_in">disable</span>-txtpages --<span class="built_in">disable</span>-encoders --<span class="built_in">disable</span>-indevs --<span class="built_in">disable</span>-outdevs --<span class="built_in">enable</span>-gnutls --samples=fate-suite/</span><br><span class="line">  libavutil      56. 55.100 / 56. 55.100</span><br><span class="line">  libavcodec     58. 96.100 / 58. 96.100</span><br><span class="line">  libavformat    58. 48.100 / 58. 48.100</span><br><span class="line">  libavdevice    58. 11.101 / 58. 11.101</span><br><span class="line">  libavfilter     7. 87.100 /  7. 87.100</span><br><span class="line">  libswscale      5.  8.100 /  5.  8.100</span><br><span class="line">  libswresample   3.  8.100 /  3.  8.100</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'http://localhost/live/out_0.m3u8'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'http://localhost/live/out_1.m3u8'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'http://localhost/live/out_0.m3u8'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'http://localhost/live/out_1.m3u8'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'http://localhost/live/out_2.m3u8'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'http://localhost/live/out_3.m3u8'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Skip (<span class="string">'#EXT-X-VERSION:3'</span>)</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_00.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_01.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_02.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_10.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_11.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_12.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_00.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_10.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_20.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_30.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_01.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_21.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_31.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_11.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_12.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_02.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_22.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_32.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">Input <span class="comment">#0, hls, from 'http://localhost/live/master.m3u8':</span></span><br><span class="line">  Duration: 00:00:40.04, start: 1.445333, bitrate: 0 kb/s</span><br><span class="line">  Program 0</span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 35200</span><br><span class="line">    Stream <span class="comment">#0:0: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 35 kb/s (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      comment         : audio_0</span><br><span class="line">    Stream <span class="comment">#0:2: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp</span></span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 35200</span><br><span class="line">  Program 1</span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 70400</span><br><span class="line">    Stream <span class="comment">#0:1: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 67 kb/s (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      comment         : audio_1</span><br><span class="line">    Stream <span class="comment">#0:3: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp</span></span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 70400</span><br><span class="line">  Program 2</span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 1135200</span><br><span class="line">    Stream <span class="comment">#0:0: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 35 kb/s (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      comment         : audio_0</span><br><span class="line">    Stream <span class="comment">#0:4: Video: h264 (High) ([27][0][0][0] / 0x001B), yuv420p, 1280x720, 30 fps, 30 tbr, 90k tbn, 60 tbc</span></span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 1135200</span><br><span class="line">  Program 3</span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 3370400</span><br><span class="line">    Stream <span class="comment">#0:1: Audio: aac (LC) ([15][0][0][0] / 0x000F), 48000 Hz, stereo, fltp, 67 kb/s (default)</span></span><br><span class="line">    Metadata:</span><br><span class="line">      comment         : audio_1</span><br><span class="line">    Stream <span class="comment">#0:5: Video: h264 (High) ([27][0][0][0] / 0x001B), yuv420p, 1280x720, 30 fps, 30 tbr, 90k tbn, 60 tbc</span></span><br><span class="line">    Metadata:</span><br><span class="line">      variant_bitrate : 3370400</span><br><span class="line">[hls @ 0x7f344c000bc0] No longer receiving playlist 1</span><br><span class="line">[hls @ 0x7f344c000bc0] No longer receiving playlist 2</span><br><span class="line">[hls @ 0x7f344c000bc0] No longer receiving playlist 3</span><br><span class="line">[hls @ 0x7f344c000bc0] No longer receiving playlist 5</span><br><span class="line">[hls @ 0x7f344c000bc0] Find current variant 2</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_23.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] [abr] switch request: 3</span><br><span class="line">[hls @ 0x7f344c000bc0] [abr] pls5, switch <span class="built_in">type</span>: 0 timestamp: 9350000</span><br><span class="line">[hls @ 0x7f344c000bc0] [abr] pls1, switch <span class="built_in">type</span>: 1 timestamp: 7429328</span><br><span class="line">[hls @ 0x7f344c000bc0] [switch point] cur_timestamp:7433333</span><br><span class="line">[hls @ 0x7f344c000bc0] No longer receiving playlist 0</span><br><span class="line">[hls @ 0x7f344c000bc0] Now receiving playlist 1, segment 3</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_13.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] [switch point] cur_timestamp:9360000</span><br><span class="line">[hls @ 0x7f344c000bc0] No longer receiving playlist 4</span><br><span class="line">[hls @ 0x7f344c000bc0] Now receiving playlist 5, segment 4</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_34.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_14.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_35.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_15.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_36.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">[hls @ 0x7f344c000bc0] Opening <span class="string">'ffabr:http://localhost/live/out_16.ts'</span> <span class="keyword">for</span> reading</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>As we can see, in this test, it seems that ffplay’s <code>av_find_best_stream</code> choose the variant 2, but the variant 3 has better quality. After download the segment “out_23.ts”, ffabr return a switch request to variant 3. Then 2 switch tasks are add, video and audio stream will switch at different timestamp, since there segment are generated sperately.</p><p>As time went by, audio stream first switched from playlist 0 to playlist 1at timestamp 7433333, then, video stream switched from playlist 4 to playlist 5. From then on, switch are finished, and ffplay played variant 3 then.</p><p>We could set loglevel <code>-v verbose</code> to see more details.</p><h2 id="ffplay-playback-problem"><a href="#ffplay-playback-problem" class="headerlink" title="ffplay playback problem"></a>ffplay playback problem</h2><h3 id="problem-explanation"><a href="#problem-explanation" class="headerlink" title="problem explanation"></a>problem explanation</h3><ol><li>Currently in ffplay, all stream packets will be added to packet list in ffplay when call function <code>avformat_find_stream_info()</code> in <code>read_thread</code> (all these are before AVDISCARD_ALL are set to streams). After this, ffplay will call <code>av_find_best_stream()</code> to decide which stream to be reserved.</li><li>Later, ffplay will check the <code>pkt-&gt;stream_index</code> and call <code>av_packet_unref(pkt)</code> to discard pkts from unwanted stream.</li><li>There are no such “unwanted stream” when we use abr. Since we do not use ffplay’s switch mechanism and switch streams transparently, ffplay should accept the packets read from different variants, and add them to its packet queue.</li></ol><p>The 3 has conflict to 1 and 2, will cause playback error in the beginning if we do not deal with it correctly.</p><h3 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h3><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ff_packet_buffer_filter</span><span class="params">(AVPacketList **pkt_buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">                         AVPacketList **pkt_buffer_end,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">int</span>           *st_index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVPacketList *pktl, *pktn;</span><br><span class="line">    av_assert0(*pkt_buffer);</span><br><span class="line">    pktl = *pkt_buffer;</span><br><span class="line">    pktn = pktl-&gt;next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* num &gt;= 2 */</span></span><br><span class="line">    <span class="keyword">while</span> (pktn) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ff_check_st_index(pktn-&gt;pkt.stream_index, st_index)) &#123;</span><br><span class="line">            av_packet_unref(&amp;pktn-&gt;pkt);</span><br><span class="line">            pktl-&gt;next = pktn-&gt;next;</span><br><span class="line">            av_freep(&amp;pktn);</span><br><span class="line">            pktn = pktl-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pktl = pktn;</span><br><span class="line">            pktn = pktn-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *pkt_buffer_end = pktl;</span><br><span class="line">    <span class="comment">/* first one*/</span></span><br><span class="line">    pktl = *pkt_buffer;</span><br><span class="line">    <span class="keyword">if</span> (!ff_check_st_index(pktl-&gt;pkt.stream_index, st_index)) &#123;</span><br><span class="line">        av_packet_unref(&amp;pktl-&gt;pkt);</span><br><span class="line">        *pkt_buffer = pktl-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (!pktl-&gt;next)</span><br><span class="line">            *pkt_buffer_end = <span class="literal">NULL</span>;</span><br><span class="line">        av_freep(&amp;pktl);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>I tried to setup <code>AVDISCARD</code>flags after <code>hls_read_header()</code>, which will prevent <code>av_read_frame()</code> to read other streams. But there are 2 problems:</p><ol><li><p>I can use variant’s bandwidth only to determine which one is the best stream, not <code>av_find_best_stream()</code>. It will cause problem if two results are different, so I even need to disable <code>av_find_best_stream()</code>.</p></li><li><p>Will cause warning:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Could not find codec parameters <span class="keyword">for</span> stream 2 (Video: h264, 1 reference frame ([27][0][0][0] / 0x001B), none): unspecified size Consider increasing the value <span class="keyword">for</span> the analyzeduration<span class="string">' (0) and '</span>probesize<span class="string">' (5000000) options".</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h4><p>Add an metadata <code>abr_initial</code> from hls to ffplay, tell ffplay to allow other streams after the timestamp of <code>stream_start_time + abr_init_duration</code>, but ffplay should discard the unwanted packets before that timestamp.</p><p>The exactly packet number added is depend on stream, but it should be less than the packet number in the segments which are downloaded during <code>hls_read_header()</code>.</p><h4 id="Solution-comparation"><a href="#Solution-comparation" class="headerlink" title="Solution comparation"></a>Solution comparation</h4><p>The solution 1 and solution 3 can both fix the problem. But I got feedback from FFmpeg community review, we don’t want to add such an api. Maybe solution 3 is more acceptable.</p><h2 id="Further-work-could-be-done"><a href="#Further-work-could-be-done" class="headerlink" title="Further work could be done"></a>Further work could be done</h2><ul><li><p>Test more HLS manifest examples.</p><p>I have tested some different HLS manifest. I would find some bugs every time when I test a new manifest. So it will benefit to test more manifest examples.</p></li><li><p>Have DASH support.</p><p>I just support HLS currently, we should support DASH further on.</p></li><li><p>Add more abr algorithms to ffabr.</p><p>There is just one simple throughput based algorithm now. Although it is difficult to implement complex ABR algorithm in FFmpeg, we could try some.</p></li></ul><h2 id="Final-words"><a href="#Final-words" class="headerlink" title="Final words"></a>Final words</h2><p>Thanks to my project mentor <em>Steven Liu</em>, <em>Jun Zhao</em>, <em>Andreas Rheinhardt</em>, <em>Nicolas George</em>, <em>Martin Storsjö</em>, <em>Moritz Barsnick</em> for such a wonderful experience.</p><h3 id="For-ABR-in-FFmpeg"><a href="#For-ABR-in-FFmpeg" class="headerlink" title="For ABR in FFmpeg"></a>For ABR in FFmpeg</h3><p>At very first, I thought the project adding ABR module to FFmpeg would be like algorithm design more. I was totally wrong, implement ABR in FFmpeg is not like dash.js, where you can get everything, and just focus on abr algorithm itself. I have to go deep into FFmpeg to learn how things are working here. It took me plenty of time to learn <code>avformat</code>, <code>avio</code>, <code>avoptions</code>… and that is just the first step to implement ABR.</p><p>As I learned more about FFmpeg, I generally understand that ABR in FFmpeg can never be something like dash.js. The two project have different purpose. What I should do is not to <code>copy</code> dash.js to FFmpeg, but write ABR in FFmpeg’s way. It may be look simple, but it is what we want.</p><p>In my perspective, my implement is not that perfect (although I tried to). There are still many things can be improve. I am not sure my code could be merged, but at least I took several months to prove that whether it is a good idea to add ABR to FFmpeg.</p><h3 id="For-GSoC"><a href="#For-GSoC" class="headerlink" title="For GSoC"></a>For GSoC</h3><p>GSoC was an impressive experience for me.</p><p>Firstly, I really learned a lot about free and open-source software(FOSS), both in philosophy and reality. I even read the book <em>Free Software, Free Society: Selected Essays of Richard M. Stallman</em>. I am shocked by the word written decades ago, and feel fortunate to have these pioneers, or maybe we would have a world full of proprietary software now, which is a disaster.</p><p>Secondly, I understood more about open-source project such as FFmpeg. I have read lots of discussion in FFmpeg-devel mailing list, for example, <em>Nicolas George</em> posted a thread on <em>Project orientation</em> in July, which have been discussed widely. Through these discussions I knew the pain in FFmpeg.</p><p>Thirdly, I have become a better programmer. I learned a lot of useful skills, use GDB for debugging, Git for version control, valgrind for memory leak checking. My mentors <em>Steven Liu</em>, <em>Jun Zhao</em> taught me what a good commit should be. FFmpeg contributers and reviews taught me how to write robust code. I prepare myself to contribute to FOSS.</p><p>SJTU should be one of the best universities in China, but few student here really understand FOSS. I feel responsible to introduce FOSS to my friends and classmates. I don’t see good FOSS environment in China, maybe we could make it better.</p><p>Regards,</p><p>Hongcheng Zhong<br><a href="mailto:spartazhc@gmail.com">spartazhc@gmail.com</a></p><hr></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>spartazhc</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/" title="ABR meets FFmpeg, in detail">https://spartazhc.github.io/2020/08/23/ABR-meets-FFmpeg-in-detail/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class="followme"><p>欢迎关注我的其它发布渠道</p><div class="social-list"><div class="social-item"><a target="_blank" class="social-link" href="/atom.xml"><span class="icon"><i class="fa fa-rss"></i> </span><span class="label">RSS</span></a></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/FFmpeg/" rel="tag"><i class="fa fa-tag"></i> FFmpeg</a> <a href="/tags/GSoC/" rel="tag"><i class="fa fa-tag"></i> GSoC</a></div><div class="post-nav"><div class="post-nav-item"><a href="/2020/06/03/Next%E4%B8%BB%E9%A2%98%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE/" rel="prev" title="Next主题字体配置"><i class="fa fa-chevron-left"></i> Next主题字体配置</a></div><div class="post-nav-item"></div></div></footer></article></div><div class="comments" id="valine-comments"></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><div class="post-toc-wrap sidebar-panel"><div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#what-are-we-talking-about-when-we-talk-ABR-in-FFmpeg"><span class="nav-number">1.</span> <span class="nav-text">what are we talking about when we talk ABR in FFmpeg?</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-ABR"><span class="nav-number">1.1.</span> <span class="nav-text">What is ABR?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Why-we-need-abr-in-FFmpeg"><span class="nav-number">1.2.</span> <span class="nav-text">Why we need abr in FFmpeg?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-different-when-add-ABR-to-FFmpeg"><span class="nav-number">1.3.</span> <span class="nav-text">What is different when add ABR to FFmpeg?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#limitations-in-FFmpeg-to-implement-ABR"><span class="nav-number">1.4.</span> <span class="nav-text">limitations in FFmpeg to implement ABR</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#What-is-done-briefly"><span class="nav-number">1.5.</span> <span class="nav-text">What is done briefly</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Structure"><span class="nav-number">2.</span> <span class="nav-text">Structure</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#original-hls"><span class="nav-number">2.1.</span> <span class="nav-text">original hls</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#segment-download"><span class="nav-number">2.1.1.</span> <span class="nav-text">segment download</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stream-cycle-switch"><span class="nav-number">2.1.2.</span> <span class="nav-text">stream cycle (switch)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ffplay-initiate-the-switch"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">ffplay initiate the switch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#hls-do-the-switch"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">hls do the switch</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#user-experience"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">user experience</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-multiple"><span class="nav-number">2.1.3.</span> <span class="nav-text">http_multiple</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-persistent"><span class="nav-number">2.1.4.</span> <span class="nav-text">http_persistent</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#hls-ffabr"><span class="nav-number">2.2.</span> <span class="nav-text">hls + ffabr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ffabr-protocol"><span class="nav-number">3.</span> <span class="nav-text">ffabr protocol</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Protocol-Design"><span class="nav-number">3.1.</span> <span class="nav-text">Protocol Design</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#basic-structure"><span class="nav-number">3.2.</span> <span class="nav-text">basic structure</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#throughput-based-algorithm"><span class="nav-number">3.3.</span> <span class="nav-text">throughput based algorithm</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#switch-mechanism"><span class="nav-number">4.</span> <span class="nav-text">switch mechanism</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#calculate-switch-timestamp"><span class="nav-number">4.1.</span> <span class="nav-text">calculate switch_timestamp</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#skip-mechanism-in-read-data"><span class="nav-number">4.2.</span> <span class="nav-text">skip mechanism in read_data</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#a-switch-example"><span class="nav-number">4.3.</span> <span class="nav-text">a switch example</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ffplay-playback-problem"><span class="nav-number">5.</span> <span class="nav-text">ffplay playback problem</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#problem-explanation"><span class="nav-number">5.1.</span> <span class="nav-text">problem explanation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Solutions"><span class="nav-number">5.2.</span> <span class="nav-text">Solutions</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-1"><span class="nav-number">5.2.1.</span> <span class="nav-text">Solution 1</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-2"><span class="nav-number">5.2.2.</span> <span class="nav-text">Solution 2</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-3"><span class="nav-number">5.2.3.</span> <span class="nav-text">Solution 3</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Solution-comparation"><span class="nav-number">5.2.4.</span> <span class="nav-text">Solution comparation</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Further-work-could-be-done"><span class="nav-number">6.</span> <span class="nav-text">Further work could be done</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Final-words"><span class="nav-number">7.</span> <span class="nav-text">Final words</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#For-ABR-in-FFmpeg"><span class="nav-number">7.1.</span> <span class="nav-text">For ABR in FFmpeg</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#For-GSoC"><span class="nav-number">7.2.</span> <span class="nav-text">For GSoC</span></a></li></ol></li></ol></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="spartazhc" src="/images/avatar.png"><p class="site-author-name" itemprop="name">spartazhc</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">29</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">15</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/spartazhc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;spartazhc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a></span></div><div class="cc-license motion-element" itemprop="license"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/en" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a></div></div></div></aside><div id="sidebar-dimmer"></div></div></main><footer class="footer"><div class="footer-inner"><div class="copyright">&copy; 2019 – <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="user"></i> </span><span class="author" itemprop="copyrightHolder">spartazhc</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="站点总字数">204k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">3:06</span></div><div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动</div><script>(function() {
    function leancloudSelector(url) {
      url = encodeURI(url);
      return document.getElementById(url).querySelector('.leancloud-visitors-count');
    }

    function addCount(Counter) {
      var visitors = document.querySelector('.leancloud_visitors');
      var url = decodeURI(visitors.id);
      var title = visitors.dataset.flagTitle;

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url })))
        .then(response => response.json())
        .then(({ results }) => {
          if (results.length > 0) {
            var counter = results[0];
            leancloudSelector(url).innerText = counter.time + 1;
            Counter('put', '/classes/Counter/' + counter.objectId, { time: { '__op': 'Increment', 'amount': 1 } })
              .catch(error => {
                console.error('Failed to save visitor count', error);
              });
          } else {
              leancloudSelector(url).innerText = 'Counter not initialized! More info at console err msg.';
              console.error('ATTENTION! LeanCloud counter has security bug, see how to solve it here: https://github.com/theme-next/hexo-leancloud-counter-security. \n However, you can still use LeanCloud without security, by setting `security` option to `false`.');
            
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    function showTime(Counter) {
      var visitors = document.querySelectorAll('.leancloud_visitors');
      var entries = [...visitors].map(element => {
        return decodeURI(element.id);
      });

      Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({ url: { '$in': entries } })))
        .then(response => response.json())
        .then(({ results }) => {
          for (let url of entries) {
            let target = results.find(item => item.url === url);
            leancloudSelector(url).innerText = target ? target.time : 0;
          }
        })
        .catch(error => {
          console.error('LeanCloud Counter Error', error);
        });
    }

    let { app_id, app_key, server_url } = {"enable":true,"app_id":"CyVb5GcDokobJWn5jYs0YPHx-gzGzoHsz","app_key":"BPpypYK7M7mcSQVUjgoAcQDs","server_url":"https://cyvb5gcd.lc-cn-n1-shared.com","security":true};
    function fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${api_server}/1.1${url}`, {
          method,
          headers: {
            'X-LC-Id'     : app_id,
            'X-LC-Key'    : app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      if (CONFIG.page.isPost) {
        if (CONFIG.hostname !== location.hostname) return;
        addCount(Counter);
      } else if (document.querySelectorAll('.post-title-link').length >= 1) {
        showTime(Counter);
      }
    }

    let api_server = app_id.slice(-9) !== '-MdYXbMMI' ? server_url : `https://${app_id.slice(0, 8).toLowerCase()}.api.lncldglobal.com`;

    if (api_server) {
      fetchData(api_server);
    } else {
      fetch('https://app-router.leancloud.cn/2/route?appId=' + app_id)
        .then(response => response.json())
        .then(({ api_server }) => {
          fetchData('https://' + api_server);
        });
    }
  })();</script></div></footer></div><script src="/lib/anime.min.js"></script><script src="/lib/velocity/velocity.min.js"></script><script src="/lib/velocity/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/pisces.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'CyVb5GcDokobJWn5jYs0YPHx-gzGzoHsz',
      appKey     : 'BPpypYK7M7mcSQVUjgoAcQDs',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});</script></body></html><!-- rebuild by neat -->